using System;
using System.Collections.Immutable;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Xymanek.ReactiveUI.Toolkit.Roslyn;

using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

public static class CodeGenHelpers
{
    public static PropertyDeclarationSyntax AddGeneratedByAttributes(
        this PropertyDeclarationSyntax property, Type generatorType
    )
    {
        return property
            .AddAttributeLists(
                GeneratedByAttribute(generatorType),
                AttributeList(SingletonSeparatedList(
                    Attribute(IdentifierName("global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage"))
                ))
            );
    }

    public static AttributeListSyntax GeneratedByAttribute(Type generatorType)
    {
        SyntaxToken generatorName = Literal(generatorType.FullName);
        SyntaxToken generatorVersion = Literal(generatorType.Assembly.GetName().Version.ToString());

        return AttributeList(SingletonSeparatedList(
            Attribute(IdentifierName("global::System.CodeDom.Compiler.GeneratedCode"))
                .AddArgumentListArguments(
                    AttributeArgument(LiteralExpression(SyntaxKind.StringLiteralExpression, generatorName)),
                    AttributeArgument(LiteralExpression(SyntaxKind.StringLiteralExpression, generatorVersion))
                )
        ));
    }

    private static readonly SymbolDisplayFormat? NamespaceFormatForPartial = new(
        typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces
    );

    // Based on
    // https://github.com/CommunityToolkit/dotnet/blob/96517eace88d95ec52a881e3e1ed74ea51436b40/CommunityToolkit.Mvvm.SourceGenerators/Models/HierarchyInfo.Syntax.cs
    public static CompilationUnitSyntax BuildPartial(
        INamedTypeSymbol typeSymbol,
        ImmutableArray<MemberDeclarationSyntax> memberDeclarations
    )
    {
        TypeDeclarationSyntax typeDeclarationSyntax = ClassDeclaration(typeSymbol.Name)
            .AddModifiers(Token(SyntaxKind.PartialKeyword))
            .AddMembers(memberDeclarations.ToArray());

        SyntaxTriviaList syntaxTriviaList = TriviaList(
            Comment("// <auto-generated/>"),
            Trivia(PragmaWarningDirectiveTrivia(Token(SyntaxKind.DisableKeyword), true)),
            Trivia(NullableDirectiveTrivia(Token(SyntaxKind.EnableKeyword), true))
        );


        string ns = typeSymbol.ContainingNamespace.ToDisplayString(NamespaceFormatForPartial);

        if (ns is "")
        {
            // If there is no namespace, attach the pragma directly to the declared type,
            // and skip the namespace declaration. This will produce code as follows:
            //
            // <SYNTAX_TRIVIA>
            // <TYPE_HIERARCHY>
            return
                CompilationUnit()
                    .AddMembers(typeDeclarationSyntax.WithLeadingTrivia(syntaxTriviaList))
                    .NormalizeWhitespace();
        }

        return CompilationUnit()
            .AddMembers(
                NamespaceDeclaration(IdentifierName(ns))
                    .WithLeadingTrivia(syntaxTriviaList)
                    .AddMembers(typeDeclarationSyntax)
            )
            .NormalizeWhitespace();
    }
}